{"version":3,"sources":["../bower_components/bxslider-4/src/js/jquery.bxslider.js"],"names":["$","defaults","mode","slideSelector","infiniteLoop","hideControlOnEnd","speed","easing","slideMargin","startSlide","randomStart","captions","ticker","tickerHover","adaptiveHeight","adaptiveHeightSpeed","video","useCSS","preloadImages","responsive","slideZIndex","wrapperClass","touchEnabled","swipeThreshold","oneToOneTouch","preventDefaultSwipeX","preventDefaultSwipeY","keyboardEnabled","pager","pagerType","pagerShortSeparator","pagerSelector","buildPager","pagerCustom","controls","nextText","prevText","nextSelector","prevSelector","autoControls","startText","stopText","autoControlsCombine","autoControlsSelector","auto","pause","autoStart","autoDirection","autoHover","autoDelay","autoSlideForOnePage","minSlides","maxSlides","moveSlides","slideWidth","onSliderLoad","onSlideBefore","onSlideAfter","onSlideNext","onSlidePrev","onSliderResize","fn","bxSlider","options","this","length","each","slider","el","windowWidth","window","width","windowHeight","height","init","settings","extend","parseInt","children","Math","floor","random","active","index","carousel","minThreshold","maxThreshold","working","interval","animProp","usingCSS","div","document","createElement","props","i","undefined","style","cssPrefix","replace","toLowerCase","data","attr","setup","wrap","viewport","parent","loader","prepend","css","position","getNumberSlidesShowing","overflow","maxWidth","getViewportMaxWidth","margin","float","listStyle","getSlideWidth","zIndex","display","eq","appendCaptions","last","getPagerQty","fitVids","preloadSelector","appendControls","appendControlsAuto","appendPager","after","loadElements","start","selector","callback","total","find","count","one","complete","load","slice","sliceAppend","clone","addClass","slicePrepend","append","remove","setSlidePosition","getViewportHeight","redrawSlider","initialized","bind","resizeWindow","initAuto","initTicker","updatePagerActive","updateDirectionControls","initTouch","keydown","keyPress","currentIndex","getMoveBy","add","outerHeight","max","apply","map","get","parseFloat","newElWidth","wrapWidth","slidesShowing","childWidth","first","pagerQty","ceil","breakPoint","counter","lastChild","setPositionProperty","left","outerWidth","lastShowingIndex","top","value","type","duration","params","propValue","setTimeout","updateAfterSlideTransition","unbind","resetValue","tickerLoop","animateObj","animate","populatePager","pagerHtml","linkContent","isFunction","pagerEl","html","on","clickPagerBind","next","prev","clickNextBind","clickPrevBind","directionEl","stop","autoEl","clickStartBind","clickStopBind","updateAutoControls","title","e","preventDefault","hasClass","stopAuto","goToNextSlide","goToPrevSlide","startAuto","pagerLink","currentTarget","pagerIndex","goToSlide","slideIndex","len","removeClass","oldIndex","state","focus","blur","hover","autoPaused","startPosition","idx","transform","split","totalDimens","ratio","newSpeed","abs","property","resumeSpeed","reset","animateProperty","isOnScreen","win","scrollTop","scrollLeft","right","bottom","bounds","offset","activeElementTag","activeElement","tagName","tagFilters","p","RegExp","result","exec","keyCode","touch","x","y","end","onTouchStart","originalPos","orig","originalEvent","touchPoints","changedTouches","pageX","pageY","setPointerCapture","pointerId","onTouchMove","onTouchEnd","onPointerCancel","releasePointerCapture","xMovement","yMovement","change","distance","windowWidthNew","windowHeightNew","call","direction","performTransition","filter","fadeOut","fadeIn","moveBy","requestEl","preventControlUpdate","setInterval","clearInterval","getCurrentSlide","getCurrentSlideElement","getSlideCount","isWorking","destroySlider","removeAttr","unwrap","reloadSlider","jQuery"],"mappings":"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","file":"bxslider.js","sourcesContent":["/***\n * BxSlider v4.2.3 - Fully loaded, responsive content slider\n * http://bxslider.com\n *\n * Copyright 2014, Steven Wanderski - http://stevenwanderski.com - http://bxcreative.com\n * Written while drinking Belgian ales and listening to jazz\n *\n * Released under the MIT license - http://opensource.org/licenses/MIT\n ***/\n\n;(function($){\n\n\tvar defaults = {\n\n\t\t// GENERAL\n\t\tmode: 'horizontal',\n\t\tslideSelector: '',\n\t\tinfiniteLoop: true,\n\t\thideControlOnEnd: false,\n\t\tspeed: 500,\n\t\teasing: null,\n\t\tslideMargin: 0,\n\t\tstartSlide: 0,\n\t\trandomStart: false,\n\t\tcaptions: false,\n\t\tticker: false,\n\t\ttickerHover: false,\n\t\tadaptiveHeight: false,\n\t\tadaptiveHeightSpeed: 500,\n\t\tvideo: false,\n\t\tuseCSS: true,\n\t\tpreloadImages: 'visible',\n\t\tresponsive: true,\n\t\tslideZIndex: 50,\n\t\twrapperClass: 'bx-wrapper',\n\n\t\t// TOUCH\n\t\ttouchEnabled: true,\n\t\tswipeThreshold: 50,\n\t\toneToOneTouch: true,\n\t\tpreventDefaultSwipeX: true,\n\t\tpreventDefaultSwipeY: false,\n\n\t\t// KEYBOARD\n\t\tkeyboardEnabled: false,\n\n\t\t// PAGER\n\t\tpager: true,\n\t\tpagerType: 'full',\n\t\tpagerShortSeparator: ' / ',\n\t\tpagerSelector: null,\n\t\tbuildPager: null,\n\t\tpagerCustom: null,\n\n\t\t// CONTROLS\n\t\tcontrols: true,\n\t\tnextText: 'Next',\n\t\tprevText: 'Prev',\n\t\tnextSelector: null,\n\t\tprevSelector: null,\n\t\tautoControls: false,\n\t\tstartText: 'Start',\n\t\tstopText: 'Stop',\n\t\tautoControlsCombine: false,\n\t\tautoControlsSelector: null,\n\n\t\t// AUTO\n\t\tauto: false,\n\t\tpause: 4000,\n\t\tautoStart: true,\n\t\tautoDirection: 'next',\n\t\tautoHover: false,\n\t\tautoDelay: 0,\n\t\tautoSlideForOnePage: false,\n\n\t\t// CAROUSEL\n\t\tminSlides: 1,\n\t\tmaxSlides: 1,\n\t\tmoveSlides: 0,\n\t\tslideWidth: 0,\n\n\t\t// CALLBACKS\n\t\tonSliderLoad: function(){ return true },\n\t\tonSlideBefore: function(){ return true },\n\t\tonSlideAfter: function(){ return true },\n\t\tonSlideNext: function(){ return true },\n\t\tonSlidePrev: function(){ return true },\n\t\tonSliderResize: function(){ return true }\n\t};\n\n\t$.fn.bxSlider = function(options){\n\n\t\tif(this.length === 0){\n\t\t\treturn this;\n\t\t} \n\n\t\t// support multiple elements\n\t\tif(this.length > 1){\n\t\t\tthis.each(function(){\n\t\t\t\t$(this).bxSlider(options);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\t// create a namespace to be used throughout the plugin\n\t\tvar slider = {};\n\t\t// set a reference to our slider element\n\t\tvar el = this;\n\n\t\t/**\n\t\t * Makes slideshow responsive\n\t\t */\n\t\t// first get the original window dimens (thanks a lot IE)\n\t\tvar windowWidth = $(window).width();\n\t\tvar windowHeight = $(window).height();\n\n\n\n\t\t/**\n\t\t * ===================================================================================\n\t\t * = PRIVATE FUNCTIONS\n\t\t * ===================================================================================\n\t\t */\n\n\t\t/**\n\t\t * Initializes namespace settings to be used throughout plugin\n\t\t */\n\t\tvar init = function(){\n\t\t\t// merge user-supplied options with the defaults\n\t\t\tslider.settings = $.extend({}, defaults, options);\n\t\t\t// parse slideWidth setting\n\t\t\tslider.settings.slideWidth = parseInt(slider.settings.slideWidth);\n\t\t\t// store the original children\n\t\t\tslider.children = el.children(slider.settings.slideSelector);\n\t\t\t// check if actual number of slides is less than minSlides / maxSlides\n\t\t\tif(slider.children.length < slider.settings.minSlides){ slider.settings.minSlides = slider.children.length; } \n\t\t\tif(slider.children.length < slider.settings.maxSlides){ slider.settings.maxSlides = slider.children.length; }\n\t\t\t// if random start, set the startSlide setting to random number\n\t\t\tif(slider.settings.randomStart){ slider.settings.startSlide = Math.floor(Math.random() * slider.children.length); }\n\t\t\t// store active slide information\n\t\t\tslider.active = { index: slider.settings.startSlide };\n\t\t\t// store if the slider is in carousel mode (displaying / moving multiple slides)\n\t\t\tslider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1 ? true : false;\n\t\t\t// if carousel, force preloadImages = 'all'\n\t\t\tif(slider.carousel){ slider.settings.preloadImages = 'all'; }\n\t\t\t// calculate the min / max width thresholds based on min / max number of slides\n\t\t\t// used to setup and update carousel slides dimensions\n\t\t\tslider.minThreshold = (slider.settings.minSlides * slider.settings.slideWidth) + ((slider.settings.minSlides - 1) * slider.settings.slideMargin);\n\t\t\tslider.maxThreshold = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);\n\t\t\t// store the current state of the slider (if currently animating, working is true)\n\t\t\tslider.working = false;\n\t\t\t// initialize the controls object\n\t\t\tslider.controls = {};\n\t\t\t// initialize an auto interval\n\t\t\tslider.interval = null;\n\t\t\t// determine which property to use for transitions\n\t\t\tslider.animProp = slider.settings.mode === 'vertical' ? 'top' : 'left';\n\t\t\t// determine if hardware acceleration can be used\n\t\t\tslider.usingCSS = slider.settings.useCSS && slider.settings.mode !== 'fade' && (function(){\n\t\t\t\t// create our test div element\n\t\t\t\tvar div = document.createElement('div');\n\t\t\t\t// css transition properties\n\t\t\t\tvar props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];\n\t\t\t\t// test for each property\n\t\t\t\tfor(var i in props){\n\t\t\t\t\tif(div.style[props[i]] !== undefined){\n\t\t\t\t\t\tslider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();\n\t\t\t\t\t\tslider.animProp = '-' + slider.cssPrefix + '-transform';\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}());\n\t\t\t// if vertical mode always make maxSlides and minSlides equal\n\t\t\tif(slider.settings.mode === 'vertical'){ slider.settings.maxSlides = slider.settings.minSlides; }\n\t\t\t// save original style data\n\t\t\tel.data(\"origStyle\", el.attr(\"style\"));\n\t\t\tel.children(slider.settings.slideSelector).each(function(){\n\t\t\t  $(this).data(\"origStyle\", $(this).attr(\"style\"));\n\t\t\t});\n\t\t\t// perform all DOM / CSS modifications\n\t\t\tsetup();\n\t\t};\n\n\t\t/**\n\t\t * Performs all DOM and CSS modifications\n\t\t */\n\t\tvar setup = function(){\n\t\t\t// wrap el in a wrapper\n\t\t\tel.wrap('<div class=\"' + slider.settings.wrapperClass + '\"><div class=\"bx-viewport\"></div></div>');\n\t\t\t// store a namespace reference to .bx-viewport\n\t\t\tslider.viewport = el.parent();\n\t\t\t// add a loading div to display while images are loading\n\t\t\tslider.loader = $('<div class=\"bx-loading\" />');\n\t\t\tslider.viewport.prepend(slider.loader);\n\t\t\t// set el to a massive width, to hold any needed slides\n\t\t\t// also strip any margin and padding from el\n\t\t\tel.css({\n\t\t\t\twidth: slider.settings.mode === 'horizontal' ? (slider.children.length * 1000 + 215) + '%' : 'auto',\n\t\t\t\tposition: 'absolute'\n\t\t\t});\n\t\t\t// if using CSS, add the easing property\n\t\t\tif(slider.usingCSS && slider.settings.easing){\n\t\t\t\tel.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);\n\t\t\t// if not using CSS and no easing value was supplied, use the default JS animation easing (swing)\n\t\t\t}else if(!slider.settings.easing){\n\t\t\t\tslider.settings.easing = 'swing';\n\t\t\t}\n\t\t\tvar slidesShowing = getNumberSlidesShowing();\n\t\t\t// make modifications to the viewport (.bx-viewport)\n\t\t\tslider.viewport.css({\n\t\t\t\twidth: '100%',\n\t\t\t\toverflow: 'hidden',\n\t\t\t\tposition: 'relative'\n\t\t\t});\n\t\t\tslider.viewport.parent().css({\n\t\t\t\tmaxWidth: getViewportMaxWidth()\n\t\t\t});\n\t\t\t// make modification to the wrapper (.bx-wrapper)\n\t\t\tif(!slider.settings.pager && !slider.settings.controls){\n\t\t\t\tslider.viewport.parent().css({\n\t\t\t\t\tmargin: '0 auto 0px'\n\t\t\t\t});\n\t\t\t}\n\t\t\t// apply css to all slider children\n\t\t\tslider.children.css({\n\t\t\t\t'float': slider.settings.mode === 'horizontal' ? 'left' : 'none',\n\t\t\t\tlistStyle: 'none',\n\t\t\t\tposition: 'relative'\n\t\t\t});\n\t\t\t// apply the calculated width after the float is applied to prevent scrollbar interference\n\t\t\tslider.children.css('width', getSlideWidth());\n\t\t\t// if slideMargin is supplied, add the css\n\t\t\tif(slider.settings.mode === 'horizontal' && slider.settings.slideMargin > 0){ slider.children.css('marginRight', slider.settings.slideMargin); }\n\t\t\tif(slider.settings.mode === 'vertical' && slider.settings.slideMargin > 0){ slider.children.css('marginBottom', slider.settings.slideMargin); }\n\t\t\t// if \"fade\" mode, add positioning and z-index CSS\n\t\t\tif(slider.settings.mode === 'fade'){\n\t\t\t\tslider.children.css({\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\tzIndex: 0,\n\t\t\t\t\tdisplay: 'none'\n\t\t\t\t});\n\t\t\t\t// prepare the z-index on the showing element\n\t\t\t\tslider.children.eq(slider.settings.startSlide).css({zIndex: slider.settings.slideZIndex, display: 'block'});\n\t\t\t}\n\t\t\t// create an element to contain all slider controls (pager, start / stop, etc)\n\t\t\tslider.controls.el = $('<div class=\"bx-controls\" />');\n\t\t\t// if captions are requested, add them\n\t\t\tif(slider.settings.captions){ appendCaptions(); }\n\t\t\t// check if startSlide is last slide\n\t\t\tslider.active.last = slider.settings.startSlide === getPagerQty() - 1;\n\t\t\t// if video is true, set up the fitVids plugin\n\t\t\tif(slider.settings.video){ el.fitVids(); }\n\t\t\t// set the default preload selector (visible)\n\t\t\tvar preloadSelector = slider.children.eq(slider.settings.startSlide);\n\t\t\tif(slider.settings.preloadImages === \"all\" || slider.settings.ticker){ preloadSelector = slider.children; }\n\t\t\t// only check for control addition if not in \"ticker\" mode\n\t\t\tif(!slider.settings.ticker){\n\t\t\t\t// if controls are requested, add them\n\t\t\t\tif(slider.settings.controls){ appendControls(); }\n\t\t\t\t// if auto is true, and auto controls are requested, add them\n\t\t\t\tif(slider.settings.auto && slider.settings.autoControls){ appendControlsAuto(); }\n\t\t\t\t// if pager is requested, add it\n\t\t\t\tif(slider.settings.pager){ appendPager(); }\n\t\t\t\t// if any control option is requested, add the controls wrapper\n\t\t\t\tif(slider.settings.controls || slider.settings.autoControls || slider.settings.pager){ slider.viewport.after(slider.controls.el); }\n\t\t\t// if ticker mode, do not allow a pager\n\t\t\t} else {\n\t\t\t\tslider.settings.pager = false;\n\t\t\t}\n\t\t\tloadElements(preloadSelector, start);\n\t\t};\n\n\t\tvar loadElements = function(selector, callback){\n\t\t\tvar total = selector.find('img:not([src=\"\"]), iframe').length;\n\t\t\tif(total === 0){\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar count = 0;\n\t\t\tselector.find('img:not([src=\"\"]), iframe').each(function(){\n\t\t\t\t$(this).one('load error', function(){\n\t\t\t\t  if(++count === total){ callback(); }\n\t\t\t\t}).each(function(){\n\t\t\t\t  if(this.complete){ $(this).load(); }\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Start the slider\n\t\t */\n\t\tvar start = function(){\n\t\t\t// if infinite loop, prepare additional slides\n\t\t\tif(slider.settings.infiniteLoop && slider.settings.mode !== 'fade' && !slider.settings.ticker){\n\t\t\t\tvar slice = slider.settings.mode === 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides;\n\t\t\t\tvar sliceAppend = slider.children.slice(0, slice).clone(true).addClass('bx-clone');\n\t\t\t\tvar slicePrepend = slider.children.slice(-slice).clone(true).addClass('bx-clone');\n\t\t\t\tel.append(sliceAppend).prepend(slicePrepend);\n\t\t\t}\n\t\t\t// remove the loading DOM element\n\t\t\tslider.loader.remove();\n\t\t\t// set the left / top position of \"el\"\n\t\t\tsetSlidePosition();\n\t\t\t// if \"vertical\" mode, always use adaptiveHeight to prevent odd behavior\n\t\t\tif(slider.settings.mode === 'vertical'){ slider.settings.adaptiveHeight = true; }\n\t\t\t// set the viewport height\n\t\t\tslider.viewport.height(getViewportHeight());\n\t\t\t// make sure everything is positioned just right (same as a window resize)\n\t\t\tel.redrawSlider();\n\t\t\t// onSliderLoad callback\n\t\t\tslider.settings.onSliderLoad(slider,slider.active.index);\n\t\t\t// slider has been fully initialized\n\t\t\tslider.initialized = true;\n\t\t\t// bind the resize call to the window\n\t\t\tif(slider.settings.responsive){ $(window).bind('resize', resizeWindow); }\n\t\t\t// if auto is true and has more than 1 page, start the show\n\t\t\tif(slider.settings.auto && slider.settings.autoStart && (getPagerQty() > 1 || slider.settings.autoSlideForOnePage)){ initAuto(); }\n\t\t\t// if ticker is true, start the ticker\n\t\t\tif(slider.settings.ticker){ initTicker(); }\n\t\t\t// if pager is requested, make the appropriate pager link active\n\t\t\tif(slider.settings.pager){ updatePagerActive(slider.settings.startSlide); }\n\t\t\t// check for any updates to the controls (like hideControlOnEnd updates)\n\t\t\tif(slider.settings.controls){ updateDirectionControls(); }\n\t\t\t// if touchEnabled is true, setup the touch events\n\t\t\tif(slider.settings.touchEnabled && !slider.settings.ticker){ initTouch(); }\n\t\t\t// if keyboardEnabled is true, setup the keyboard events\n\t\t\tif (slider.settings.keyboardEnabled && !slider.settings.ticker) { \n\t\t\t\t$(document).keydown(keyPress);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value\n\t\t */\n\t\tvar getViewportHeight = function(){\n\t\t\tvar height = 0;\n\t\t\t// first determine which children (slides) should be used in our height calculation\n\t\t\tvar children = $();\n\t\t\t// if mode is not \"vertical\" and adaptiveHeight is false, include all children\n\t\t\tif(slider.settings.mode !== 'vertical' && !slider.settings.adaptiveHeight){\n\t\t\t\tchildren = slider.children;\n\t\t\t}else{\n\t\t\t\t// if not carousel, return the single active child\n\t\t\t\tif(!slider.carousel){\n\t\t\t\t\tchildren = slider.children.eq(slider.active.index);\n\t\t\t\t// if carousel, return a slice of children\n\t\t\t\t}else{\n\t\t\t\t\t// get the individual slide index\n\t\t\t\t\tvar currentIndex = slider.settings.moveSlides === 1 ? slider.active.index : slider.active.index * getMoveBy();\n\t\t\t\t\t// add the current slide to the children\n\t\t\t\t\tchildren = slider.children.eq(currentIndex);\n\t\t\t\t\t// cycle through the remaining \"showing\" slides\n\t\t\t\t\tfor (i = 1; i <= slider.settings.maxSlides - 1; i++){\n\t\t\t\t\t\t// if looped back to the start\n\t\t\t\t\t\tif(currentIndex + i >= slider.children.length){\n\t\t\t\t\t\t\tchildren = children.add(slider.children.eq(i - 1));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tchildren = children.add(slider.children.eq(currentIndex + i));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if \"vertical\" mode, calculate the sum of the heights of the children\n\t\t\tif(slider.settings.mode === 'vertical'){\n\t\t\t\tchildren.each(function(index){\n\t\t\t\t  height += $(this).outerHeight();\n\t\t\t\t});\n\t\t\t\t// add user-supplied margins\n\t\t\t\tif(slider.settings.slideMargin > 0){\n\t\t\t\t\theight += slider.settings.slideMargin * (slider.settings.minSlides - 1);\n\t\t\t\t}\n\t\t\t// if not \"vertical\" mode, calculate the max height of the children\n\t\t\t}else{\n\t\t\t\theight = Math.max.apply(Math, children.map(function(){\n\t\t\t\t\treturn $(this).outerHeight(false);\n\t\t\t\t}).get());\n\t\t\t}\n\n\t\t\tif(slider.viewport.css('box-sizing') === 'border-box'){\n\t\t\t\theight +=\tparseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom')) +\n\t\t\t\t\t\t\tparseFloat(slider.viewport.css('border-top-width')) + parseFloat(slider.viewport.css('border-bottom-width'));\n\t\t\t}else if(slider.viewport.css('box-sizing') === 'padding-box'){\n\t\t\t\theight +=\tparseFloat(slider.viewport.css('padding-top')) + parseFloat(slider.viewport.css('padding-bottom'));\n\t\t\t}\n\n\t\t\treturn height;\n\t\t};\n\n\t\t/**\n\t\t * Returns the calculated width to be used for the outer wrapper / viewport\n\t\t */\n\t\tvar getViewportMaxWidth = function(){\n\t\t\tvar width = '100%';\n\t\t\tif(slider.settings.slideWidth > 0){\n\t\t\t\tif(slider.settings.mode === 'horizontal'){\n\t\t\t\t\twidth = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);\n\t\t\t\t}else{\n\t\t\t\t\twidth = slider.settings.slideWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn width;\n\t\t};\n\n\t\t/**\n\t\t * Returns the calculated width to be applied to each slide\n\t\t */\n\t\tvar getSlideWidth = function(){\n\t\t\t// start with any user-supplied slide width\n\t\t\tvar newElWidth = slider.settings.slideWidth;\n\t\t\t// get the current viewport width\n\t\t\tvar wrapWidth = slider.viewport.width();\n\t\t\t// if slide width was not supplied, or is larger than the viewport use the viewport width\n\t\t\tif(slider.settings.slideWidth === 0 ||\n\t\t\t\t(slider.settings.slideWidth > wrapWidth && !slider.carousel) ||\n\t\t\t\tslider.settings.mode === 'vertical'){\n\t\t\t\tnewElWidth = wrapWidth;\n\t\t\t// if carousel, use the thresholds to determine the width\n\t\t\t}else if(slider.settings.maxSlides > 1 && slider.settings.mode === 'horizontal'){\n\t\t\t\tif(wrapWidth > slider.maxThreshold){\n\t\t\t\t\t// newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.maxSlides - 1))) / slider.settings.maxSlides;\n\t\t\t\t}else if(wrapWidth < slider.minThreshold){\n\t\t\t\t\tnewElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.minSlides - 1))) / slider.settings.minSlides;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newElWidth;\n\t\t};\n\n\t\t/**\n\t\t * Returns the number of slides currently visible in the viewport (includes partially visible slides)\n\t\t */\n\t\tvar getNumberSlidesShowing = function(){\n\t\t\tvar slidesShowing = 1;\n\t\t\tif(slider.settings.mode === 'horizontal' && slider.settings.slideWidth > 0){\n\t\t\t\t// if viewport is smaller than minThreshold, return minSlides\n\t\t\t\tif(slider.viewport.width() < slider.minThreshold){\n\t\t\t\t\tslidesShowing = slider.settings.minSlides;\n\t\t\t\t// if viewport is larger than maxThreshold, return maxSlides\n\t\t\t\t}else if(slider.viewport.width() > slider.maxThreshold){\n\t\t\t\t\tslidesShowing = slider.settings.maxSlides;\n\t\t\t\t// if viewport is between min / max thresholds, divide viewport width by first child width\n\t\t\t\t}else{\n\t\t\t\t\tvar childWidth = slider.children.first().width() + slider.settings.slideMargin;\n\t\t\t\t\tslidesShowing = Math.floor((slider.viewport.width() +\n\t\t\t\t\t\tslider.settings.slideMargin) / childWidth);\n\t\t\t\t}\n\t\t\t// if \"vertical\" mode, slides showing will always be minSlides\n\t\t\t}else if(slider.settings.mode === 'vertical'){\n\t\t\t\tslidesShowing = slider.settings.minSlides;\n\t\t\t}\n\t\t\treturn slidesShowing;\n\t\t};\n\n\t\t/**\n\t\t * Returns the number of pages (one full viewport of slides is one \"page\")\n\t\t */\n\t\tvar getPagerQty = function(){\n\t\t\tvar pagerQty = 0;\n\t\t\t// if moveSlides is specified by the user\n\t\t\tif(slider.settings.moveSlides > 0){\n\t\t\t\tif(slider.settings.infiniteLoop){\n\t\t\t\t\tpagerQty = Math.ceil(slider.children.length / getMoveBy());\n\t\t\t\t}else{\n\t\t\t\t\t// use a while loop to determine pages\n\t\t\t\t\tvar breakPoint = 0;\n\t\t\t\t\tvar counter = 0;\n\t\t\t\t\t// when breakpoint goes above children length, counter is the number of pages\n\t\t\t\t\twhile (breakPoint < slider.children.length){\n\t\t\t\t\t\t++pagerQty;\n\t\t\t\t\t\tbreakPoint = counter + getNumberSlidesShowing();\n\t\t\t\t\t\tcounter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t// if moveSlides is 0 (auto) divide children length by sides showing, then round up\n\t\t\t}else{\n\t\t\t\tpagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());\n\t\t\t}\n\t\t\treturn pagerQty;\n\t\t};\n\n\t\t/**\n\t\t * Returns the number of individual slides by which to shift the slider\n\t\t */\n\t\tvar getMoveBy = function(){\n\t\t\t// if moveSlides was set by the user and moveSlides is less than number of slides showing\n\t\t\tif(slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()){\n\t\t\t\treturn slider.settings.moveSlides;\n\t\t\t}\n\t\t\t// if moveSlides is 0 (auto)\n\t\t\treturn getNumberSlidesShowing();\n\t\t};\n\n\t\t/**\n\t\t * Sets the slider's (el) left or top position\n\t\t */\n\t\tvar setSlidePosition = function(){\n\t\t\tvar position;\n\t\t\t// if last slide, not infinite loop, and number of children is larger than specified maxSlides\n\t\t\tif(slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop){\n\t\t\t\tif(slider.settings.mode === 'horizontal'){\n\t\t\t\t\t// get the last child's position\n\t\t\t\t\tvar lastChild = slider.children.last();\n\t\t\t\t\tposition = lastChild.position();\n\t\t\t\t\t// set the left position\n\t\t\t\t\tsetPositionProperty(-(position.left - (slider.viewport.width() - lastChild.outerWidth())), 'reset', 0);\n\t\t\t\t}else if(slider.settings.mode === 'vertical'){\n\t\t\t\t\t// get the last showing index's position\n\t\t\t\t\tvar lastShowingIndex = slider.children.length - slider.settings.minSlides;\n\t\t\t\t\tposition = slider.children.eq(lastShowingIndex).position();\n\t\t\t\t\t// set the top position\n\t\t\t\t\tsetPositionProperty(-position.top, 'reset', 0);\n\t\t\t\t}\n\t\t\t// if not last slide\n\t\t\t}else{\n\t\t\t\t// get the position of the first showing slide\n\t\t\t\tposition = slider.children.eq(slider.active.index * getMoveBy()).position();\n\t\t\t\t// check for last slide\n\t\t\t\tif(slider.active.index === getPagerQty() - 1){ slider.active.last = true; }\n\t\t\t\t// set the respective position\n\t\t\t\tif(position !== undefined){\n\t\t\t\t\tif(slider.settings.mode === 'horizontal'){ setPositionProperty(-position.left, 'reset', 0); }\n\t\t\t\t\telse if(slider.settings.mode === 'vertical'){ setPositionProperty(-position.top, 'reset', 0); }\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Sets the el's animating property position (which in turn will sometimes animate el).\n\t\t * If using CSS, sets the transform property. If not using CSS, sets the top / left property.\n\t\t *\n\t\t * @param value (int)\n\t\t *  - the animating property's value\n\t\t *\n\t\t * @param type (string) 'slide', 'reset', 'ticker'\n\t\t *  - the type of instance for which the function is being\n\t\t *\n\t\t * @param duration (int)\n\t\t *  - the amount of time (in ms) the transition should occupy\n\t\t *\n\t\t * @param params (array) optional\n\t\t *  - an optional parameter containing any variables that need to be passed in\n\t\t */\n\t\tvar setPositionProperty = function(value, type, duration, params){\n\t\t\t// use CSS transform\n\t\t\tif(slider.usingCSS){\n\t\t\t\t// determine the translate3d value\n\t\t\t\tvar propValue = slider.settings.mode === 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';\n\t\t\t\t// add the CSS transition-duration\n\t\t\t\tel.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');\n\t\t\t\tif(type === 'slide'){\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t// set the property value\n\t\t\t\t\t\tel.css(slider.animProp, propValue);\n\t\t\t\t\t\t// if value 0, just update\n\t\t\t\t\t\tif(value === 0) {\n\t\t\t\t\t\t\tupdateAfterSlideTransition();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// bind a callback method - executes when CSS transition completes\n\t\t\t\t\t\t\tel.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){\n\t\t\t\t\t\t\t\t// unbind the callback\n\t\t\t\t\t\t\t\tel.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\n\t\t\t\t\t\t\t\tupdateAfterSlideTransition();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0);\n\t\t\t\t}else if(type === 'reset'){\n\t\t\t\t\tel.css(slider.animProp, propValue);\n\t\t\t\t}else if(type === 'ticker'){\n\t\t\t\t\t// make the transition use 'linear'\n\t\t\t\t\tel.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');\n\t\t\t\t\tel.css(slider.animProp, propValue);\n\t\t\t\t\t// bind a callback method - executes when CSS transition completes\n\t\t\t\t\tel.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){\n\t\t\t\t\t\t// unbind the callback\n\t\t\t\t\t\tel.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');\n\t\t\t\t\t\t// reset the position\n\t\t\t\t\t\tsetPositionProperty(params.resetValue, 'reset', 0);\n\t\t\t\t\t\t// start the loop again\n\t\t\t\t\t\ttickerLoop();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t// use JS animate\n\t\t\t}else{\n\t\t\t\tvar animateObj = {};\n\t\t\t\tanimateObj[slider.animProp] = value;\n\t\t\t\tif(type === 'slide'){\n\t\t\t\t\tel.animate(animateObj, duration, slider.settings.easing, function(){\n\t\t\t\t\t\tupdateAfterSlideTransition();\n\t\t\t\t\t});\n\t\t\t\t}else if(type === 'reset'){\n\t\t\t\t\tel.css(slider.animProp, value);\n\t\t\t\t}else if(type === 'ticker'){\n\t\t\t\t\tel.animate(animateObj, speed, 'linear', function(){\n\t\t\t\t\t\tsetPositionProperty(params.resetValue, 'reset', 0);\n\t\t\t\t\t\t// run the recursive loop after animation\n\t\t\t\t\t\ttickerLoop();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Populates the pager with proper amount of pages\n\t\t */\n\t\tvar populatePager = function(){\n\t\t\tvar pagerHtml = '';\n\t\t\tvar pagerQty = getPagerQty();\n\t\t\t// loop through each pager item\n\t\t\tfor(var i=0; i < pagerQty; i++){\n\t\t\t\tvar linkContent = '';\n\t\t\t\t// if a buildPager function is supplied, use it to get pager link value, else use index + 1\n\t\t\t\tif(slider.settings.buildPager && $.isFunction(slider.settings.buildPager) || slider.settings.pagerCustom){\n\t\t\t\t\tlinkContent = slider.settings.buildPager(i);\n\t\t\t\t\tslider.pagerEl.addClass('bx-custom-pager');\n\t\t\t\t}else{\n\t\t\t\t\tlinkContent = i + 1;\n\t\t\t\t\tslider.pagerEl.addClass('bx-default-pager');\n\t\t\t\t}\n\t\t\t\t// var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;\n\t\t\t\t// add the markup to the string\n\t\t\t\tpagerHtml += '<div class=\"bx-pager-item\"><a href=\"\" data-slide-index=\"' + i + '\" class=\"bx-pager-link\">' + linkContent + '</a></div>';\n\t\t\t}\n\t\t\t// populate the pager element with pager links\n\t\t\tslider.pagerEl.html(pagerHtml);\n\t\t};\n\n\t\t/**\n\t\t * Appends the pager to the controls element\n\t\t */\n\t\tvar appendPager = function(){\n\t\t\tif(!slider.settings.pagerCustom){\n\t\t\t\t// create the pager DOM element\n\t\t\t\tslider.pagerEl = $('<div class=\"bx-pager\" />');\n\t\t\t\t// if a pager selector was supplied, populate it with the pager\n\t\t\t\tif(slider.settings.pagerSelector){\n\t\t\t\t\t$(slider.settings.pagerSelector).html(slider.pagerEl);\n\t\t\t\t// if no pager selector was supplied, add it after the wrapper\n\t\t\t\t}else{\n\t\t\t\t\tslider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);\n\t\t\t\t}\n\t\t\t\t// populate the pager\n\t\t\t\tpopulatePager();\n\t\t\t}else{\n\t\t\t\tslider.pagerEl = $(slider.settings.pagerCustom);\n\t\t\t}\n\t\t\t// assign the pager click binding\n\t\t\tslider.pagerEl.on('click touchend', 'a', clickPagerBind);\n\t\t};\n\n\t\t/**\n\t\t * Appends prev / next controls to the controls element\n\t\t */\n\t\tvar appendControls = function(){\n\t\t\tslider.controls.next = $('<a class=\"bx-next\" href=\"\">' + slider.settings.nextText + '</a>');\n\t\t\tslider.controls.prev = $('<a class=\"bx-prev\" href=\"\">' + slider.settings.prevText + '</a>');\n\t\t\t// bind click actions to the controls\n\t\t\tslider.controls.next.bind('click touchend', clickNextBind);\n\t\t\tslider.controls.prev.bind('click touchend', clickPrevBind);\n\t\t\t// if nextSelector was supplied, populate it\n\t\t\tif(slider.settings.nextSelector){\n\t\t\t\t$(slider.settings.nextSelector).append(slider.controls.next);\n\t\t\t}\n\t\t\t// if prevSelector was supplied, populate it\n\t\t\tif(slider.settings.prevSelector){\n\t\t\t\t$(slider.settings.prevSelector).append(slider.controls.prev);\n\t\t\t}\n\t\t\t// if no custom selectors were supplied\n\t\t\tif(!slider.settings.nextSelector && !slider.settings.prevSelector){\n\t\t\t\t// add the controls to the DOM\n\t\t\t\tslider.controls.directionEl = $('<div class=\"bx-controls-direction\" />');\n\t\t\t\t// add the control elements to the directionEl\n\t\t\t\tslider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);\n\t\t\t\t// slider.viewport.append(slider.controls.directionEl);\n\t\t\t\tslider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Appends start / stop auto controls to the controls element\n\t\t */\n\t\tvar appendControlsAuto = function(){\n\t\t\tslider.controls.start = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-start\" href=\"\">' + slider.settings.startText + '</a></div>');\n\t\t\tslider.controls.stop = $('<div class=\"bx-controls-auto-item\"><a class=\"bx-stop\" href=\"\">' + slider.settings.stopText + '</a></div>');\n\t\t\t// add the controls to the DOM\n\t\t\tslider.controls.autoEl = $('<div class=\"bx-controls-auto\" />');\n\t\t\t// bind click actions to the controls\n\t\t\tslider.controls.autoEl.on('click', '.bx-start', clickStartBind);\n\t\t\tslider.controls.autoEl.on('click', '.bx-stop', clickStopBind);\n\t\t\t// if autoControlsCombine, insert only the \"start\" control\n\t\t\tif(slider.settings.autoControlsCombine){\n\t\t\t\tslider.controls.autoEl.append(slider.controls.start);\n\t\t\t// if autoControlsCombine is false, insert both controls\n\t\t\t}else{\n\t\t\t\tslider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);\n\t\t\t}\n\t\t\t// if auto controls selector was supplied, populate it with the controls\n\t\t\tif(slider.settings.autoControlsSelector){\n\t\t\t\t$(slider.settings.autoControlsSelector).html(slider.controls.autoEl);\n\t\t\t// if auto controls selector was not supplied, add it after the wrapper\n\t\t\t}else{\n\t\t\t\tslider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);\n\t\t\t}\n\t\t\t// update the auto controls\n\t\t\tupdateAutoControls(slider.settings.autoStart ? 'stop' : 'start');\n\t\t};\n\n\t\t/**\n\t\t * Appends image captions to the DOM\n\t\t */\n\t\tvar appendCaptions = function(){\n\t\t\t// cycle through each child\n\t\t\tslider.children.each(function(index){\n\t\t\t\t// get the image title attribute\n\t\t\t\tvar title = $(this).find('img:first').attr('title');\n\t\t\t\t// append the caption\n\t\t\t\tif(title !== undefined && ('' + title).length){\n\t\t\t\t\t$(this).append('<div class=\"bx-caption\"><span>' + title + '</span></div>');\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Click next binding\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar clickNextBind = function(e){\n\t\t\te.preventDefault();\n\t\t\tif (slider.controls.el.hasClass('disabled')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// if auto show is running, stop it\n\t\t\tif(slider.settings.auto){ el.stopAuto(); }\n\t\t\tel.goToNextSlide();\n\t\t};\n\n\t\t/**\n\t\t * Click prev binding\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar clickPrevBind = function(e){\n\t\t\te.preventDefault();\n\t\t\tif (slider.controls.el.hasClass('disabled')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// if auto show is running, stop it\n\t\t\tif(slider.settings.auto){ el.stopAuto(); }\n\t\t\tel.goToPrevSlide();\n\t\t};\n\n\t\t/**\n\t\t * Click start binding\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar clickStartBind = function(e){\n\t\t\tel.startAuto();\n\t\t\te.preventDefault();\n\t\t};\n\n\t\t/**\n\t\t * Click stop binding\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar clickStopBind = function(e){\n\t\t\tel.stopAuto();\n\t\t\te.preventDefault();\n\t\t};\n\n\t\t/**\n\t\t * Click pager binding\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar clickPagerBind = function(e){\n\t\t\te.preventDefault();\n\t\t\tif (slider.controls.el.hasClass('disabled')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// if auto show is running, stop it\n\t\t\tif(slider.settings.auto){ el.stopAuto(); }\n\t\t\tvar pagerLink = $(e.currentTarget);\n\t\t\tif(pagerLink.attr('data-slide-index') !== undefined){\n\t\t\t\tvar pagerIndex = parseInt(pagerLink.attr('data-slide-index'));\n\t\t\t\t// if clicked pager link is not active, continue with the goToSlide call\n\t\t\t\tif(pagerIndex !== slider.active.index){ el.goToSlide(pagerIndex); }\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Updates the pager links with an active class\n\t\t *\n\t\t * @param slideIndex (int)\n\t\t *  - index of slide to make active\n\t\t */\n\t\tvar updatePagerActive = function(slideIndex){\n\t\t\t// if \"short\" pager type\n\t\t\tvar len = slider.children.length; // nb of children\n\t\t\tif(slider.settings.pagerType === 'short'){\n\t\t\t\tif(slider.settings.maxSlides > 1){\n\t\t\t\t\tlen = Math.ceil(slider.children.length/slider.settings.maxSlides);\n\t\t\t\t}\n\t\t\t\tslider.pagerEl.html( (slideIndex + 1) + slider.settings.pagerShortSeparator + len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// remove all pager active classes\n\t\t\tslider.pagerEl.find('a').removeClass('active');\n\t\t\t// apply the active class for all pagers\n\t\t\tslider.pagerEl.each(function(i, el){ $(el).find('a').eq(slideIndex).addClass('active'); });\n\t\t};\n\n\t\t/**\n\t\t * Performs needed actions after a slide transition\n\t\t */\n\t\tvar updateAfterSlideTransition = function(){\n\t\t\t// if infinite loop is true\n\t\t\tif(slider.settings.infiniteLoop){\n\t\t\t\tvar position = '';\n\t\t\t\t// first slide\n\t\t\t\tif(slider.active.index === 0){\n\t\t\t\t\t// set the new position\n\t\t\t\t\tposition = slider.children.eq(0).position();\n\t\t\t\t// carousel, last slide\n\t\t\t\t}else if(slider.active.index === getPagerQty() - 1 && slider.carousel){\n\t\t\t\t\tposition = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();\n\t\t\t\t// last slide\n\t\t\t\t}else if(slider.active.index === slider.children.length - 1){\n\t\t\t\t\tposition = slider.children.eq(slider.children.length - 1).position();\n\t\t\t\t}\n\t\t\t\tif(position){\n\t\t\t\t\tif(slider.settings.mode === 'horizontal'){ setPositionProperty(-position.left, 'reset', 0); }\n\t\t\t\t\telse if(slider.settings.mode === 'vertical'){ setPositionProperty(-position.top, 'reset', 0); }\n\t\t\t\t}\n\t\t\t}\n\t\t\t// declare that the transition is complete\n\t\t\tslider.working = false;\n\t\t\t// onSlideAfter callback\n\t\t\tslider.settings.onSlideAfter(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\n\t\t};\n\n\t\t/**\n\t\t * Updates the auto controls state (either active, or combined switch)\n\t\t *\n\t\t * @param state (string) \"start\", \"stop\"\n\t\t *  - the new state of the auto show\n\t\t */\n\t\tvar updateAutoControls = function(state){\n\t\t\t// if autoControlsCombine is true, replace the current control with the new state\n\t\t\tif(slider.settings.autoControlsCombine){\n\t\t\t\tslider.controls.autoEl.html(slider.controls[state]);\n\t\t\t// if autoControlsCombine is false, apply the \"active\" class to the appropriate control\n\t\t\t}else{\n\t\t\t\tslider.controls.autoEl.find('a').removeClass('active');\n\t\t\t\tslider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Updates the direction controls (checks if either should be hidden)\n\t\t */\n\t\tvar updateDirectionControls = function(){\n\t\t\tif(getPagerQty() === 1){\n\t\t\t\tslider.controls.prev.addClass('disabled');\n\t\t\t\tslider.controls.next.addClass('disabled');\n\t\t\t}else if(!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd){\n\t\t\t\t// if first slide\n\t\t\t\tif(slider.active.index === 0){\n\t\t\t\t\tslider.controls.prev.addClass('disabled');\n\t\t\t\t\tslider.controls.next.removeClass('disabled');\n\t\t\t\t// if last slide\n\t\t\t\t}else if(slider.active.index === getPagerQty() - 1){\n\t\t\t\t\tslider.controls.next.addClass('disabled');\n\t\t\t\t\tslider.controls.prev.removeClass('disabled');\n\t\t\t\t// if any slide in the middle\n\t\t\t\t}else{\n\t\t\t\t\tslider.controls.prev.removeClass('disabled');\n\t\t\t\t\tslider.controls.next.removeClass('disabled');\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Initializes the auto process\n\t\t */\n\t\tvar initAuto = function(){\n\t\t\t// if autoDelay was supplied, launch the auto show using a setTimeout() call\n\t\t\tif(slider.settings.autoDelay > 0){\n\t\t\t\tvar timeout = setTimeout(el.startAuto, slider.settings.autoDelay);\n\t\t\t// if autoDelay was not supplied, start the auto show normally\n\t\t\t}else{\n\t\t\t\tel.startAuto();\n\n\t\t\t\t//add focus and blur events to ensure its running if timeout gets paused\n\t\t\t\t$(window).focus(function() {\n\t\t\t\t\tel.startAuto();\n\t\t\t\t}).blur(function() {\n\t\t\t\t\tel.stopAuto();\n\t\t\t\t});\n\t\t\t\t\n\n\t\t\t}\n\t\t\t// if autoHover is requested\n\t\t\tif(slider.settings.autoHover){\n\t\t\t\t// on el hover\n\t\t\t\tel.hover(function(){\n\t\t\t\t\t// if the auto show is currently playing (has an active interval)\n\t\t\t\t\tif(slider.interval){\n\t\t\t\t\t\t// stop the auto show and pass true argument which will prevent control update\n\t\t\t\t\t\tel.stopAuto(true);\n\t\t\t\t\t\t// create a new autoPaused value which will be used by the relative \"mouseout\" event\n\t\t\t\t\t\tslider.autoPaused = true;\n\t\t\t\t\t}\n\t\t\t\t}, function(){\n\t\t\t\t\t// if the autoPaused value was created be the prior \"mouseover\" event\n\t\t\t\t\tif(slider.autoPaused){\n\t\t\t\t\t\t// start the auto show and pass true argument which will prevent control update\n\t\t\t\t\t\tel.startAuto(true);\n\t\t\t\t\t\t// reset the autoPaused value\n\t\t\t\t\t\tslider.autoPaused = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Initializes the ticker process\n\t\t */\n\t\tvar initTicker = function(){\n\t\t\tvar startPosition = 0;\n\t\t\t// if autoDirection is \"next\", append a clone of the entire slider\n\t\t\tif(slider.settings.autoDirection === 'next'){\n\t\t\t\tel.append(slider.children.clone().addClass('bx-clone'));\n\t\t\t// if autoDirection is \"prev\", prepend a clone of the entire slider, and set the left position\n\t\t\t}else{\n\t\t\t\tel.prepend(slider.children.clone().addClass('bx-clone'));\n\t\t\t\tvar position = slider.children.first().position();\n\t\t\t\tstartPosition = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\n\t\t\t}\n\t\t\tsetPositionProperty(startPosition, 'reset', 0);\n\t\t\t// do not allow controls in ticker mode\n\t\t\tslider.settings.pager = false;\n\t\t\tslider.settings.controls = false;\n\t\t\tslider.settings.autoControls = false;\n\t\t\t// if autoHover is requested\n\t\t\tif(slider.settings.tickerHover){\n\t\t\t\tif(slider.usingCSS){\n\t\t\t\t\tvar value;\n\t\t\t\t\tvar idx = slider.settings.mode == 'horizontal' ? 4 : 5;\n\t\t\t\t\tslider.viewport.hover(function(){\n\t\t\t\t\t\tvar transform = el.css('-' + slider.cssPrefix + '-transform');\n\t\t\t\t\t\tvalue = parseFloat(transform.split(',')[idx]);\n\t\t\t\t\t\tsetPositionProperty(value, 'reset', 0);\n\t\t\t\t\t}, function(){\n\t\t\t\t\t\tvar totalDimens = 0;\n\t\t\t\t\t\tslider.children.each(function(index){\n\t\t\t\t\t\t  totalDimens += slider.settings.mode == 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// calculate the speed ratio (used to determine the new speed to finish the paused animation)\n\t\t\t\t\t\tvar ratio = slider.settings.speed / totalDimens;\n\t\t\t\t\t\t// determine which property to use\n\t\t\t\t\t\tvar property = slider.settings.mode == 'horizontal' ? 'left' : 'top';\n\t\t\t\t\t\t// calculate the new speed\n\t\t\t\t\t\tvar newSpeed = ratio * (totalDimens - (Math.abs(parseInt(value))));\n\t\t\t\t\t\ttickerLoop(newSpeed);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// on el hover\n\t\t\t\t\tslider.viewport.hover(function(){\n\t\t\t\t\t\tel.stop();\n\t\t\t\t\t}, function(){\n\t\t\t\t\t\t// calculate the total width of children (used to calculate the speed ratio)\n\t\t\t\t\t\tvar totalDimens = 0;\n\t\t\t\t\t\tslider.children.each(function(index){\n\t\t\t\t\t\t  totalDimens += slider.settings.mode == 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t// calculate the speed ratio (used to determine the new speed to finish the paused animation)\n\t\t\t\t\t\tvar ratio = slider.settings.speed / totalDimens;\n\t\t\t\t\t\t// determine which property to use\n\t\t\t\t\t\tvar property = slider.settings.mode == 'horizontal' ? 'left' : 'top';\n\t\t\t\t\t\t// calculate the new speed\n\t\t\t\t\t\tvar newSpeed = ratio * (totalDimens - (Math.abs(parseInt(el.css(property)))));\n\t\t\t\t\t\ttickerLoop(newSpeed);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// start the ticker loop\n\t\t\ttickerLoop();\n\t\t};\n\n\t\t/**\n\t\t * Runs a continuous loop, news ticker-style\n\t\t */\n\t\tvar tickerLoop = function(resumeSpeed){\n\t\t\tspeed = resumeSpeed ? resumeSpeed : slider.settings.speed;\n\t\t\tvar position = {left: 0, top: 0};\n\t\t\tvar reset = {left: 0, top: 0};\n\t\t\t// if \"next\" animate left position to last child, then reset left to 0\n\t\t\tif(slider.settings.autoDirection === 'next'){\n\t\t\t\tposition = el.find('.bx-clone').first().position();\n\t\t\t// if \"prev\" animate left position to 0, then reset left to first non-clone child\n\t\t\t}else{\n\t\t\t\treset = slider.children.first().position();\n\t\t\t}\n\t\t\tvar animateProperty = slider.settings.mode === 'horizontal' ? -position.left : -position.top;\n\t\t\tvar resetValue = slider.settings.mode === 'horizontal' ? -reset.left : -reset.top;\n\t\t\tvar params = {resetValue: resetValue};\n\t\t\tsetPositionProperty(animateProperty, 'ticker', speed, params);\n\t\t};\n\n\t\t/**\n\t\t * Check if el is on screen\n\t\t */\n\t\tvar isOnScreen = function(el){\n\t\t\tvar win = $(window);\n\t\t\tvar viewport = {\n\t\t\t\ttop : win.scrollTop(),\n\t\t\t\tleft : win.scrollLeft()\n\t\t\t};\n\t\t\tviewport.right = viewport.left + win.width();\n\t\t\tviewport.bottom = viewport.top + win.height();\n\n\t\t\tvar bounds = el.offset();\n\t\t\tbounds.right = bounds.left + el.outerWidth();\n\t\t\tbounds.bottom = bounds.top + el.outerHeight();\n\n\t\t\treturn (!(viewport.right < bounds.left || viewport.left > bounds.right || viewport.bottom < bounds.top || viewport.top > bounds.bottom));\n\t\t};\n\n\t\t/**\n\t\t * Initializes keyboard events\n\t\t */\n\t\tvar keyPress = function(e){\n\t\t\tvar activeElementTag = document.activeElement.tagName.toLowerCase();\n\t\t\tvar tagFilters='input|textarea';\n\t\t\tvar p = new RegExp(activeElementTag,[\"i\"]);\n\t\t\tvar result = p.exec(tagFilters);\n\t\t\tif (result == null && isOnScreen(el)) {\n\t\t\t\tif (e.keyCode == 39) {\n\t\t\t\t\tclickNextBind(e);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse if (e.keyCode == 37) {\n\t\t\t\t\tclickPrevBind(e);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Initializes touch events\n\t\t */\n\t\tvar initTouch = function(){\n\t\t\t// initialize object to contain all touch values\n\t\t\tslider.touch = {\n\t\t\t\tstart: {x: 0, y: 0},\n\t\t\t\tend: {x: 0, y: 0}\n\t\t\t};\n\t\t\tslider.viewport.bind('touchstart MSPointerDown pointerdown', onTouchStart);\n\t\t\t\n\t\t\t//for browsers that have implemented pointer events and fire a click after\n\t\t\t//every pointerup regardless of whether pointerup is on same screen location as pointerdown or not\n\t\t\tslider.viewport.on('click', '.bxslider a', function(e) {\n\t\t\t\tif (slider.viewport.hasClass('click-disabled')) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tslider.viewport.removeClass('click-disabled');\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Event handler for \"touchstart\"\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar onTouchStart = function(e){\n\t\t\t//disable slider controls while user is interacting with slides to avoid slider freeze that happens on touch devices when a slide swipe happens immediately after interacting with slider controls\n\t\t\tslider.controls.el.addClass('disabled');\n\n\t\t\tif(slider.working){\n\t\t\t\te.preventDefault();\n\t\t\t\tslider.controls.el.removeClass('disabled');\n\t\t\t}else{\n\t\t\t\t// record the original position when touch starts\n\t\t\t\tslider.touch.originalPos = el.position();\n\t\t\t\tvar orig = e.originalEvent;\n\t\t\t\tvar touchPoints = (typeof orig.changedTouches != 'undefined') ? orig.changedTouches : [orig];\n\t\t\t\t// record the starting touch x, y coordinates\n\t\t\t\tslider.touch.start.x = touchPoints[0].pageX;\n\t\t\t\tslider.touch.start.y = touchPoints[0].pageY;\n\n\t\t\t\tif (slider.viewport.get(0).setPointerCapture) {\n\t\t\t\t\tslider.pointerId = orig.pointerId;\n\t\t\t\t\tslider.viewport.get(0).setPointerCapture(slider.pointerId);\n\t\t\t\t}\n\t\t\t\t// bind a \"touchmove\" event to the viewport\n\t\t\t\tslider.viewport.bind('touchmove MSPointerMove pointermove', onTouchMove);\n\t\t\t\t// bind a \"touchend\" event to the viewport\n\t\t\t\tslider.viewport.bind('touchend MSPointerUp pointerup', onTouchEnd);\n\t\t\t\tslider.viewport.bind('MSPointerCancel pointercancel', onPointerCancel);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Cancel Pointer for Windows Phone\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar onPointerCancel = function(e) {\n\t\t/* onPointerCancel handler is needed to deal with situations when a touchend\n\t\tdoesn't fire after a touchstart (this happens on windows phones only) */\n\t\t\tsetPositionProperty(slider.touch.originalPos.left, 'reset', 0);\n\n\t\t\t//remove handlers\n\t\t\tslider.controls.el.removeClass('disabled');\n\t\t\tslider.viewport.unbind('MSPointerCancel pointercancel', onPointerCancel);\n\t\t\tslider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\n\t\t\tslider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\n\t\t\tif (slider.viewport.get(0).releasePointerCapture) {\n\t\t\t\tslider.viewport.get(0).releasePointerCapture(slider.pointerId);\n \t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Event handler for \"touchmove\"\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar onTouchMove = function(e){\n\t\t\tvar orig = e.originalEvent;\n\t\t\tvar touchPoints = (typeof orig.changedTouches != 'undefined') ? orig.changedTouches : [orig];\n\t\t\t// if scrolling on y axis, do not prevent default\n\t\t\tvar xMovement = Math.abs(touchPoints[0].pageX - slider.touch.start.x);\n\t\t\tvar yMovement = Math.abs(touchPoints[0].pageY - slider.touch.start.y);\n\t\t\t// x axis swipe\n\t\t\tif((xMovement * 3) > yMovement && slider.settings.preventDefaultSwipeX){\n\t\t\t\te.preventDefault();\n\t\t\t// y axis swipe\n\t\t\t}else if((yMovement * 3) > xMovement && slider.settings.preventDefaultSwipeY){\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tif(slider.settings.mode !== 'fade' && slider.settings.oneToOneTouch){\n\t\t\t\tvar value = 0, change = 0;\n\t\t\t\t// if horizontal, drag along x axis\n\t\t\t\tif(slider.settings.mode === 'horizontal'){\n\t\t\t\t\tchange = touchPoints[0].pageX - slider.touch.start.x;\n\t\t\t\t\tvalue = slider.touch.originalPos.left + change;\n\t\t\t\t// if vertical, drag along y axis\n\t\t\t\t}else{\n\t\t\t\t\tchange = touchPoints[0].pageY - slider.touch.start.y;\n\t\t\t\t\tvalue = slider.touch.originalPos.top + change;\n\t\t\t\t}\n\t\t\t\tsetPositionProperty(value, 'reset', 0);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Event handler for \"touchend\"\n\t\t *\n\t\t * @param e (event)\n\t\t *  - DOM event object\n\t\t */\n\t\tvar onTouchEnd = function(e){\n\t\t\tslider.viewport.unbind('touchmove MSPointerMove pointermove', onTouchMove);\n\t\t\t//enable slider controls as soon as user stops interacing with slides\n\t\t\tslider.controls.el.removeClass('disabled');\n\t\t\tvar orig = e.originalEvent;\n\t\t\tvar touchPoints = (typeof orig.changedTouches != 'undefined') ? orig.changedTouches : [orig];\n\t\t\tvar value = 0;\n\t\t\tvar distance = 0;\n\t\t\t// record end x, y positions\n\t\t\tslider.touch.end.x = touchPoints[0].pageX;\n\t\t\tslider.touch.end.y = touchPoints[0].pageY;\n\t\t\t// if fade mode, check if absolute x distance clears the threshold\n\t\t\tif(slider.settings.mode === 'fade'){\n\t\t\t\tdistance = Math.abs(slider.touch.start.x - slider.touch.end.x);\n\t\t\t\tif(distance >= slider.settings.swipeThreshold){\n\t\t\t\t\tif(slider.touch.start.x > slider.touch.end.x){\n\t\t\t\t\t\tel.goToNextSlide();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.goToPrevSlide();\n\t\t\t\t\t} \n\t\t\t\t\tel.stopAuto();\n\t\t\t\t}\n\t\t\t// not fade mode\n\t\t\t}else{\n\t\t\t\t// calculate distance and el's animate property\n\t\t\t\tif(slider.settings.mode === 'horizontal'){\n\t\t\t\t\tdistance = slider.touch.end.x - slider.touch.start.x;\n\t\t\t\t\tvalue = slider.touch.originalPos.left;\n\t\t\t\t}else{\n\t\t\t\t\tdistance = slider.touch.end.y - slider.touch.start.y;\n\t\t\t\t\tvalue = slider.touch.originalPos.top;\n\t\t\t\t}\n\t\t\t\t// if not infinite loop and first / last slide, do not attempt a slide transition\n\t\t\t\tif(!slider.settings.infiniteLoop && ((slider.active.index === 0 && distance > 0) || (slider.active.last && distance < 0))){\n\t\t\t\t\tsetPositionProperty(value, 'reset', 200);\n\t\t\t\t}else{\n\t\t\t\t\t// check if distance clears threshold\n\t\t\t\t\tif(Math.abs(distance) >= slider.settings.swipeThreshold){\n\t\t\t\t\t\tif(distance < 0){\n\t\t\t\t\t\t\tel.goToNextSlide();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tel.goToPrevSlide();\n\t\t\t\t\t\t} \n\t\t\t\t\t\tel.stopAuto();\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// el.animate(property, 200);\n\t\t\t\t\t\tsetPositionProperty(value, 'reset', 200);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tslider.viewport.unbind('touchend MSPointerUp pointerup', onTouchEnd);\n\t\t\tif (slider.viewport.get(0).releasePointerCapture) {\n\t\t\t\tslider.viewport.get(0).releasePointerCapture(slider.pointerId);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Window resize event callback\n\t\t */\n\t\tvar resizeWindow = function(e){\n\t\t\t// don't do anything if slider isn't initialized.\n\t\t\tif(!slider.initialized){ return; }\n\t\t\t// Delay if slider working.\n\t\t\tif (slider.working) {\n\t\t\t\twindow.setTimeout(resizeWindow, 10);\n\t\t\t} else {\n\t\t\t\t// get the new window dimens (again, thank you IE)\n\t\t\t\tvar windowWidthNew = $(window).width();\n\t\t\t\tvar windowHeightNew = $(window).height();\n\t\t\t\t// make sure that it is a true window resize\n\t\t\t\t// *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements\n\t\t\t\t// are resized. Can you just die already?*\n\t\t\t\tif(windowWidth !== windowWidthNew || windowHeight !== windowHeightNew){\n\t\t\t\t\t// set the new window dimens\n\t\t\t\t\twindowWidth = windowWidthNew;\n\t\t\t\t\twindowHeight = windowHeightNew;\n\t\t\t\t\t// update all dynamic elements\n\t\t\t\t\tel.redrawSlider();\n\t\t\t\t\t// Call user resize handler\n\t\t\t\t\tslider.settings.onSliderResize.call(el, slider.active.index);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * ===================================================================================\n\t\t * = PUBLIC FUNCTIONS\n\t\t * ===================================================================================\n\t\t */\n\n\t\t/**\n\t\t * Performs slide transition to the specified slide\n\t\t *\n\t\t * @param slideIndex (int)\n\t\t *  - the destination slide's index (zero-based)\n\t\t *\n\t\t * @param direction (string)\n\t\t *  - INTERNAL USE ONLY - the direction of travel (\"prev\" / \"next\")\n\t\t */\n\t\tel.goToSlide = function(slideIndex, direction){\n\t\t\t// if plugin is currently in motion, ignore request\n\t\t\tif(slider.working || slider.active.index === slideIndex){ return; }\n\t\t\t// declare that plugin is in motion\n\t\t\tslider.working = true;\n\t\t\t// store the old index\n\t\t\tslider.oldIndex = slider.active.index;\n\t\t\t// if slideIndex is less than zero, set active index to last child (this happens during infinite loop)\n\t\t\tif(slideIndex < 0){\n\t\t\t\tslider.active.index = getPagerQty() - 1;\n\t\t\t// if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)\n\t\t\t}else if(slideIndex >= getPagerQty()){\n\t\t\t\tslider.active.index = 0;\n\t\t\t// set active index to requested slide\n\t\t\t}else{\n\t\t\t\tslider.active.index = slideIndex;\n\t\t\t}\n\t\t\t// onSlideBefore, onSlideNext, onSlidePrev callbacks\n\t\t\t// Allow transition canceling based on returned value\n\t\t\tvar performTransition = true;\n\n\t\t\tperformTransition = slider.settings.onSlideBefore(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);\n\t\t\t\n\t\t\tif ( typeof(performTransition) !== \"undefined\" && !performTransition ) {\n\t\t\t\tslider.active.index = slider.oldIndex; // restore old index\n\t\t\t\tslider.working = false; // is not in motion\n\t\t\t\treturn;\t\n\t\t\t}\n\t\t\tif(direction === 'next'){\n\t\t\t\t// Prevent canceling in future functions or lack there-of from negating previous commands to cancel\n\t\t\t\tif(!slider.settings.onSlideNext(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)){\n\t\t\t\t\tperformTransition = false;\n\t\t\t\t}\n\t\t\t}else if(direction === 'prev'){\n\t\t\t\t// Prevent canceling in future functions or lack there-of from negating previous commands to cancel\n\t\t\t\tif(!slider.settings.onSlidePrev(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index)){\n\t\t\t\t\tperformTransition = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If transitions canceled, reset and return\n\t\t\tif ( typeof(performTransition) !== \"undefined\" && !performTransition ) {\n\t\t\t\tslider.active.index = slider.oldIndex; // restore old index\n\t\t\t\tslider.working = false; // is not in motion\n\t\t\t\treturn;\t\n\t\t\t}\n\n\t\t\t// check if last slide\n\t\t\tslider.active.last = slider.active.index >= getPagerQty() - 1;\n\t\t\t// update the pager with active class\n\t\t\tif(slider.settings.pager || slider.settings.pagerCustom){ updatePagerActive(slider.active.index); }\n\t\t\t// // check for direction control update\n\t\t\tif(slider.settings.controls){ updateDirectionControls(); }\n\t\t\t// if slider is set to mode: \"fade\"\n\t\t\tif(slider.settings.mode === 'fade'){\n\t\t\t\t// if adaptiveHeight is true and next height is different from current height, animate to the new height\n\t\t\t\tif(slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()){\n\t\t\t\t\tslider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);\n\t\t\t\t}\n\t\t\t\t// fade out the visible child and reset its z-index value\n\t\t\t\tslider.children.filter(':visible').fadeOut(slider.settings.speed).css({zIndex: 0});\n\t\t\t\t// fade in the newly requested slide\n\t\t\t\tslider.children.eq(slider.active.index).css('zIndex', slider.settings.slideZIndex+1).fadeIn(slider.settings.speed, function(){\n\t\t\t\t\t$(this).css('zIndex', slider.settings.slideZIndex);\n\t\t\t\t\tupdateAfterSlideTransition();\n\t\t\t\t});\n\t\t\t// slider mode is not \"fade\"\n\t\t\t}else{\n\t\t\t\t// if adaptiveHeight is true and next height is different from current height, animate to the new height\n\t\t\t\tif(slider.settings.adaptiveHeight && slider.viewport.height() !== getViewportHeight()){\n\t\t\t\t\tslider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);\n\t\t\t\t}\n\t\t\t\tvar moveBy = 0;\n\t\t\t\tvar position = {left: 0, top: 0};\n\t\t\t\tvar lastChild = null;\n\t\t\t\t// if carousel and not infinite loop\n\t\t\t\tif(!slider.settings.infiniteLoop && slider.carousel && slider.active.last){\n\t\t\t\t\tif(slider.settings.mode === 'horizontal'){\n\t\t\t\t\t\t// get the last child position\n\t\t\t\t\t\tlastChild = slider.children.eq(slider.children.length - 1);\n\t\t\t\t\t\tposition = lastChild.position();\n\t\t\t\t\t\t// calculate the position of the last slide\n\t\t\t\t\t\tmoveBy = slider.viewport.width() - lastChild.outerWidth();\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// get last showing index position\n\t\t\t\t\t\tvar lastShowingIndex = slider.children.length - slider.settings.minSlides;\n\t\t\t\t\t\tposition = slider.children.eq(lastShowingIndex).position();\n\t\t\t\t\t}\n\t\t\t\t\t// horizontal carousel, going previous while on first slide (infiniteLoop mode)\n\t\t\t\t}else if(slider.carousel && slider.active.last && direction === 'prev'){\n\t\t\t\t\t// get the last child position\n\t\t\t\t\tvar eq = slider.settings.moveSlides === 1 ? slider.settings.maxSlides - getMoveBy() : ((getPagerQty() - 1) * getMoveBy()) - (slider.children.length - slider.settings.maxSlides);\n\t\t\t\t\tlastChild = el.children('.bx-clone').eq(eq);\n\t\t\t\t\tposition = lastChild.position();\n\t\t\t\t// if infinite loop and \"Next\" is clicked on the last slide\n\t\t\t\t}else if(direction === 'next' && slider.active.index === 0){\n\t\t\t\t\t// get the last clone position\n\t\t\t\t\tposition = el.find('> .bx-clone').eq(slider.settings.maxSlides).position();\n\t\t\t\t\tslider.active.last = false;\n\t\t\t\t// normal non-zero requests\n\t\t\t\t}else if(slideIndex >= 0){\n\t\t\t\t\tvar requestEl = slideIndex * getMoveBy();\n\t\t\t\t\tposition = slider.children.eq(requestEl).position();\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t/* If the position doesn't exist\n\t\t\t\t * (e.g. if you destroy the slider on a next click),\n\t\t\t\t * it doesn't throw an error.\n\t\t\t\t */\n\t\t\t\tif(\"undefined\" !== typeof(position)){\n\t\t\t\t\tvar value = slider.settings.mode === 'horizontal' ? -(position.left - moveBy) : -position.top;\n\t\t\t\t\t// plugin values to be animated\n\t\t\t\t\tsetPositionProperty(value, 'slide', slider.settings.speed);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Transitions to the next slide in the show\n\t\t */\n\t\tel.goToNextSlide = function(){\n\t\t\t// if infiniteLoop is false and last page is showing, disregard call\n\t\t\tif(!slider.settings.infiniteLoop && slider.active.last){ return; }\n\t\t\tvar pagerIndex = parseInt(slider.active.index) + 1;\n\t\t\tel.goToSlide(pagerIndex, 'next');\n\t\t};\n\n\t\t/**\n\t\t * Transitions to the prev slide in the show\n\t\t */\n\t\tel.goToPrevSlide = function(){\n\t\t\t// if infiniteLoop is false and last page is showing, disregard call\n\t\t\tif(!slider.settings.infiniteLoop && slider.active.index === 0){ return; }\n\t\t\tvar pagerIndex = parseInt(slider.active.index) - 1;\n\t\t\tel.goToSlide(pagerIndex, 'prev');\n\t\t};\n\n\t\t/**\n\t\t * Starts the auto show\n\t\t *\n\t\t * @param preventControlUpdate (boolean)\n\t\t *  - if true, auto controls state will not be updated\n\t\t */\n\t\tel.startAuto = function(preventControlUpdate){\n\t\t\t// if an interval already exists, disregard call\n\t\t\tif(slider.interval){ return; }\n\t\t\t// create an interval\n\t\t\tslider.interval = setInterval(function(){\n\t\t\t\tif(slider.settings.autoDirection === 'next'){ \n\t\t\t\t\tel.goToNextSlide(); \n\t\t\t\t}else{\n\t\t\t\t\tel.goToPrevSlide();\n\t\t\t\t}\n\t\t\t}, slider.settings.pause);\n\t\t\t// if auto controls are displayed and preventControlUpdate is not true\n\t\t\tif(slider.settings.autoControls && preventControlUpdate !== true){ updateAutoControls('stop'); }\n\t\t};\n\n\t\t/**\n\t\t * Stops the auto show\n\t\t *\n\t\t * @param preventControlUpdate (boolean)\n\t\t *  - if true, auto controls state will not be updated\n\t\t */\n\t\tel.stopAuto = function(preventControlUpdate){\n\t\t\t// if no interval exists, disregard call\n\t\t\tif(!slider.interval){ return; }\n\t\t\t// clear the interval\n\t\t\tclearInterval(slider.interval);\n\t\t\tslider.interval = null;\n\t\t\t// if auto controls are displayed and preventControlUpdate is not true\n\t\t\tif(slider.settings.autoControls && preventControlUpdate !== true){ updateAutoControls('start'); }\n\t\t};\n\n\t\t/**\n\t\t * Returns current slide index (zero-based)\n\t\t */\n\t\tel.getCurrentSlide = function(){\n\t\t\treturn slider.active.index;\n\t\t};\n\n\t\t/**\n\t\t * Returns current slide element\n\t\t */\n\t\tel.getCurrentSlideElement = function(){\n\t\t\treturn slider.children.eq(slider.active.index);\n\t\t};\n\n\t\t/**\n\t\t * Returns number of slides in show\n\t\t */\n\t\tel.getSlideCount = function(){\n\t\t\treturn slider.children.length;\n\t\t};\n\n\t\t/**\n\t\t * Return slider.working variable\n\t\t */\n\t\tel.isWorking = function() {\n\t\t\treturn slider.working;\n\t\t}\n\n\t\t/**\n\t\t * Update all dynamic slider elements\n\t\t */\n\t\tel.redrawSlider = function(){\n\t\t\t// resize all children in ratio to new screen size\n\t\t\tslider.children.add(el.find('.bx-clone')).outerWidth(getSlideWidth());\n\t\t\t// adjust the height\n\t\t\tslider.viewport.css('height', getViewportHeight());\n\t\t\t// update the slide position\n\t\t\tif(!slider.settings.ticker) { setSlidePosition(); }                 \n\t\t\t// if active.last was true before the screen resize, we want\n\t\t\t// to keep it last no matter what screen size we end on\n\t\t\tif (slider.active.last) { slider.active.index = getPagerQty() - 1; }\n\t\t\t// if the active index (page) no longer exists due to the resize, simply set the index as last\n\t\t\tif (slider.active.index >= getPagerQty()) { slider.active.last = true; }\n\t\t\t// if a pager is being displayed and a custom pager is not being used, update it\n\t\t\tif(slider.settings.pager && !slider.settings.pagerCustom){\n\t\t\t\tpopulatePager();\n\t\t\t\tupdatePagerActive(slider.active.index);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Destroy the current instance of the slider (revert everything back to original state)\n\t\t */\n\t\tel.destroySlider = function(){\n\t\t\t// don't do anything if slider has already been destroyed\n\t\t\tif(!slider.initialized){ return; }\n\t\t\tslider.initialized = false;\n\t\t\t$('.bx-clone', this).remove();\n\t\t\tslider.children.each(function(){\n\t\t\t\tif($(this).data(\"origStyle\") !== undefined){\n\t\t\t\t\t$(this).attr(\"style\", $(this).data(\"origStyle\"));\n\t\t\t\t} else {\n\t\t\t\t\t$(this).removeAttr('style');\n\t\t\t\t}\n\t\t\t});\n\t\t\tif($(this).data(\"origStyle\") !== undefined){\n\t\t\t\tthis.attr(\"style\", $(this).data(\"origStyle\"));\n\t\t\t} else {\n\t\t\t\t$(this).removeAttr('style');\n\t\t\t}\n\t\t\t$(this).unwrap().unwrap();\n\t\t\tif(slider.controls.el){ slider.controls.el.remove(); }\n\t\t\tif(slider.controls.next){ slider.controls.next.remove(); }\n\t\t\tif(slider.controls.prev){ slider.controls.prev.remove(); }\n\t\t\tif(slider.pagerEl && slider.settings.controls && !slider.settings.pagerCustom){ slider.pagerEl.remove(); }\n\t\t\t$('.bx-caption', this).remove();\n\t\t\tif(slider.controls.autoEl){ slider.controls.autoEl.remove(); }\n\t\t\tclearInterval(slider.interval);\n\t\t\tif(slider.settings.responsive){ $(window).unbind('resize', resizeWindow); }\n\t\t\tif(slider.settings.keyboardEnabled){ $(document).unbind('keydown', keyPress); }\n\t\t};\n\n\t\t/**\n\t\t * Reload the slider (revert all DOM changes, and re-initialize)\n\t\t */\n\t\tel.reloadSlider = function(settings){\n\t\t\tif(settings !== undefined){ options = settings; }\n\t\t\tel.destroySlider();\n\t\t\tinit();\n\t\t};\n\n\t\tinit();\n\n\t\t// returns the current jQuery object\n\t\treturn this;\n\t};\n\n})(jQuery);\n"],"sourceRoot":"assets/scripts/"}